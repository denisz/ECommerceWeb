import * as _ from 'underscore';

export const isRussia = (e) => {
  const t = e.split(", ");
  return "Россия" === t[t.length - 1]
};

export const isNotStreet = (t) => {
  return !["улица", "бульвар", "переулок", "проспект", "шоссе", "площадь", "микрорайон", "лесопарк"]
    .some((e) => ( -1 < t.text.indexOf(e) ))
};

export const isCity = (e) => {
  if (e) {
    let t = e.split(", ")[0];
    if (t) return (t = t.split(" ")[0]) !== t.toLowerCase()
  }
  return false
};

export const prepareCityNameForGeocoding = (e) => {
  const t = e.split(", "), s = t.length;
  return 3 === s && "Россия" !== t[s - 1] ? (t.splice(s - 2, 1), t.join(", ")) : e
};

export const parseStreet = (e) => {
  const components = e.get('metaDataProperty.GeocoderMetaData.Address.Components');
  const component = components.find((i) => ( i.kind === 'street'));
  if (component) return component.name;
  return '';
};

export const parseHouse = (e) => {
  const components = e.get('metaDataProperty.GeocoderMetaData.Address.Components');
  const component = components.find((i) => ( i.kind === 'house'));
  if (component) return component.name;
  return '';
};

export const parseGeoMetaData = (e) => {
  return {
    street: parseStreet(e),
    house: parseHouse(e),
    country: e.get("metaDataProperty.GeocoderMetaData.AddressDetails.Country.CountryName", ""),
    region: e.get("metaDataProperty.GeocoderMetaData.AddressDetails.Country.AdministrativeArea.AdministrativeAreaName")
    || e.get("metaDataProperty.GeocoderMetaData.AddressDetails.AdministrativeArea.AdministrativeAreaName")
    || "",
    district: e.get("metaDataProperty.GeocoderMetaData.AddressDetails.Country.AdministrativeArea.SubAdministrativeArea.SubAdministrativeAreaName")
    || e.get("metaDataProperty.GeocoderMetaData.AddressDetails.AdministrativeArea.SubAdministrativeArea.SubAdministrativeAreaName")
    || "",
    city: e.get("metaDataProperty.GeocoderMetaData.AddressDetails.Country.Locality.LocalityName")
    || e.get("metaDataProperty.GeocoderMetaData.AddressDetails.Country.AdministrativeArea.Locality.LocalityName")
    || e.get("metaDataProperty.GeocoderMetaData.AddressDetails.Country.AdministrativeArea.SubAdministrativeArea.Locality.LocalityName")
    || e.get("metaDataProperty.GeocoderMetaData.AddressDetails.Country.AdministrativeArea.SubAdministrativeArea.Locality.Premise.PremiseName")
    || e.get("metaDataProperty.GeocoderMetaData.AddressDetails.AdministrativeArea.SubAdministrativeArea.Locality.LocalityName")
    || e.get("metaDataProperty.GeocoderMetaData.AddressDetails.AdministrativeArea.Locality.LocalityName")
    || e.get("metaDataProperty.GeocoderMetaData.AddressDetails.Locality.LocalityName"),
  };
};

export const containsRussiaToken = (e, t) => {
  t || (t = "ru_RU");
  return -1 !== e.indexOf({
      ru_RU: "Россия",
      en_US: "Russian Federation"
    }[t])
};

export const localityDisplayName = (e) => {
  const t = e.city.split(" ");
  const s = t.findIndex((e) => {
    const t = e[0];
    return t.toUpperCase() === t || _.isFinite(t)
  });
  return t.slice(s).join(" ")
};

export const handleChange = async (request) => {
  let props = { request };
  if (!window.ymaps || request === '') return props;

  try {
    await window.ymaps.ready();

    let geocode = await window.ymaps.geocode(request, { results: 1 });
    props.locality = parseGeoMetaData(geocode.geoObjects.get(0).properties);
    props.geoPoint = geocode.geoObjects.get(0).geometry.getCoordinates();
    props.name = localityDisplayName(props.locality);
  } catch (e) {
    console.log(e);
  }

  return props;
};
