import { defaults, isEmpty, noop, findWhere, property, isObject, isFunction, extend, indexOf } from 'underscore';
import assert from 'assert';

const defaultDelegate = {
  navControllerWillChange: noop,
  navControllerDidChange: noop,
  navControllerDidRichEnd: noop,
  navControllerDidRichStart: noop,
};

function filterTransition(transitions) {
  return transitions.filter(i => !i.disabled);
}

export default class Controller {
  constructor(delegate = defaultDelegate, transitions, props) {
    assert(Array.isArray(transitions), 'Transitions is not recognized as a Array.');

    this.state = defaults(props, {
      transitions,
      currentState: 0,
      defaultState: 0,
      lastOperation: null,
    });

    const pureTransitions = filterTransition(this.state.transitions);
    assert(!isEmpty(pureTransitions), 'Transitions declared, but without a value into array.');

    this.state.transitions = pureTransitions;

    this.delegate = delegate;

    this.next = ::this.next;
    this.back = ::this.back;
    this.rewind = ::this.rewind;
  }

  setDelegate(delegate) {
    this.delegate = delegate;
  }

  async willTransition(object) {
    if (isObject(this.delegate) && isFunction(this.delegate.navControllerWillChange)) {
      await this.delegate.navControllerWillChange(this, object.currentState);
    }
  }

  async didTransition(object) {
    if (isObject(this.delegate) && isFunction(this.delegate.navControllerDidChange)) {
      await this.delegate.navControllerDidChange(this, object.currentState);
    }
  }

  didRichEnd() {
    if (isObject(this.delegate) && isFunction(this.delegate.navControllerDidRichEnd)) {
      return this.delegate.navControllerDidRichEnd(this);
    }
    return null;
  }

  didRichStart() {
    if (isObject(this.delegate) && isFunction(this.delegate.navControllerDidRichStart)) {
      return this.delegate.navControllerDidRichStart(this);
    }
    return null;
  }

  async setState(object) {
    await this.willTransition(object);
    this.state = extend(this.state, object);
    await this.didTransition(object);
  }

  currentState() {
    return this.state.currentState;
  }

  transitions() {
    return this.state.transitions;
  }

  get count() {
    return this.transitions().length;
  }

  getStateByKey(key) {
    return findWhere(this.transitions(), { key });
  }

  getIndexOfByKey(key) {
    const state = this.getStateByKey(key);
    return indexOf(this.transitions(), state);
  }

  async setStateByIndex(index) {
    await this.setForceState(index);
  }

  async setStateByKey(key) {
    let index = this.getIndexOfByKey(key);

    if (index === -1) {
      index = this.state.defaultState;
    }

    await this.setForceState(index);
  }

  async setForceState(nextState) {
    const maxState = this.count;

    if (maxState > nextState && nextState >= 0) {
      await this.setState({
        lastOperation: 'set',
        currentState: nextState,
      });
    }
  }

  get prefs() {
    return this.currentPrefs();
  }

  currentPrefs() {
    return this.prefsByState(this.currentState());
  }

  prefsByState(state) {
    let statePrefs = property(state)(this.transitions());

    if (!statePrefs) {
      statePrefs = property(0)(this.transitions());
    }

    return statePrefs;
  }

  get canBack() {
    const maxState = this.count;
    const currentState = this.currentState();
    const nextState = currentState - 1;

    return maxState > nextState && nextState >= 0;
  }

  async back() {
    const maxState = this.count;
    const currentState = this.currentState();
    const nextState = currentState - 1;

    if (maxState > nextState && nextState >= 0) {
      await this.setState({
        lastOperation: 'back',
        currentState: nextState,
      });
    } else {
      this.didRichStart();
    }
  }

  get canForward() {
    const maxState = this.count;
    const currentState = this.currentState();
    const nextState = currentState + 1;

    return maxState > nextState;
  }

  async next() {
    const maxState = this.count;
    const currentState = this.currentState();
    const nextState = currentState + 1;

    if (maxState > nextState) {
      await this.setState({
        lastOperation: 'next',
        currentState: nextState,
      });
    } else {
      this.didRichEnd();
    }
  }

  async rewind() {
    switch (this.state.lastOperation) {
      case 'next': await this.next(); break;
      case 'back': await this.back(); break;
      default: break;
    }
  }
}
