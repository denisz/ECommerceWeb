import join from 'url-join';
import shellescape from 'shell-escape';
import parseUri from 'modules/ParseUri/ParseUri';
import { apiURL, apiBasePath } from '../../../config';
import checkStatus, { checkError } from './CheckStatus';

const urlDecode = params => Object.keys(params).map(key => `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`).join('&');

const isHTTPUrl = (url) => {
  if (typeof url === 'string') {
    return url.indexOf('http') === 0;
  }

  return false;
};

export const AuthMethods = {
  BASIC: Symbol('basic'),
  JWT: Symbol('jwt'),
};

const noBodyMethods = new Set(['GET', 'DELETE']);

const kHeaders = Symbol('headers');
const kBaseURL = Symbol('baseURL');
const kURL = Symbol('URL');
const kBasePath = Symbol('basePath');
const kMethod = Symbol('method');
const kBody = Symbol('body');
const kPath = Symbol('path');
const kAuth = Symbol('auth');
const kURLParams = Symbol('urlParams');
const kEncode = Symbol('encode');
const kCredentials = Symbol('credentials');

export default class URLRequest {
  constructor(url) {
    this[kBaseURL] = url || URLRequest.baseURL;
    this[kHeaders] = {};
    this[kURL] = null;
    this[kMethod] = 'POST';
    this[kBasePath] = URLRequest.basePath || '';
    this[kBody] = {};
    this[kPath] = [];
    this[kAuth] = null;
    this[kURLParams] = {};
    this[kEncode] = 'json';
    this[kCredentials] = 'omit';// 'include';
  }

  get hostname() {
    const attrs = parseUri(this[kBaseURL]);
    return attrs.host;
  }

  get port() {
    const attrs = parseUri(this[kBaseURL]);
    return attrs.port;
  }

  get protocol() {
    const attrs = parseUri(this[kBaseURL]);
    return attrs.protocol;
  }

  get ssl() {
    return this.protocol === 'https';
  }

  get path() {
    if (this.basePath) {
      return [].concat(this.basePath, this[kPath]);
    }

    return this[kPath];
  }

  get baseUrl() {
    return this[kBaseURL];
  }

  get body() {
    const method = this.method;
    return !noBodyMethods.has(method) ? this.bodyEncoded() : null;
  }

  get method() {
    return this[kMethod];
  }

  get query() {
    return this[kURLParams];
  }

  get href() {
    return this.url;
  }

  get basePath() {
    return this[kBasePath];
  }

  get absoluteUrl() {
    const readyUrl = this[kURL];
    if (readyUrl) {
      return readyUrl;
    }

    return join(this.baseUrl, ...this.path);
  }

  get url() {
    const url = this.absoluteUrl;
    const query = urlDecode(this[kURLParams]);

    if (query) {
      return `${url}?${query}`;
    }

    return url;
  }

  get headers() {
    const headers = Object.assign({}, this[kHeaders]);

    switch (this[kEncode]) {
      case 'json':
        headers['Content-Type'] = 'application/json';
        break;
      case 'urlencoded':
        headers['Content-Type'] = 'application/x-www-form-urlencoded';
        break;
      default:
    }

    headers['Access-Control-Request-Headers'] = 'X-JWT-Token';
    return headers;
  }

  get credentials() {
    return this[kCredentials];
  }

  setURL(url) {
    if (!isHTTPUrl(url)) throw new Error('Invalid URL schema');
    this[kURL] = url;
    return this;
  }

  setCredentials(credential) {
    this[kCredentials] = credential;
  }

  setPath(path) {
    this[kPath] = this[kPath].concat(path);
    return this;
  }

  setEncode(type) {
    this[kEncode] = type;
    return this;
  }

  setMethod(method) {
    this[kMethod] = method;
    return this;
  }

  setBody(body) {
    this[kBody] = body;
    return this;
  }

  setAuth(auth) {
    if (!auth) return this;

    const { authMethod, payload } = auth;
    this[kAuth] = { authMethod, payload };
    return this;
  }

  appendUrlParams(key, val) {
    if (!key) return this;

    let urlParams = {};

    if (typeof key === 'object') {
      urlParams = key;
    } else {
      urlParams = { [key]: val };
    }

    this[kURLParams] = Object.assign({}, this[kURLParams], urlParams);
    return this;
  }

  appendPayload(key, val) {
    let attrs = {};

    if (typeof key === 'object') {
      attrs = key;
    } else {
      attrs = { [key]: val };
    }

    this[kBody] = Object.assign({}, this[kBody], attrs);
    return this;
  }

  appendHeader(key, value) {
    this[kHeaders][key] = value;
    return this;
  }

  bodyEncoded() {
    const params = this[kBody];

    switch (this[kEncode]) {
      case 'json':
        return JSON.stringify(params);
      case 'urlencoded':
        return urlDecode(params);
      case 'binary':
        return params;
      default:
        return params;
    }
  }

  getAuthData() {
    if (this[kAuth]) {
      return this[kAuth];
    }

    const authMethod = URLRequest.authMethod;
    const payload = URLRequest.authentications.get(authMethod);

    return { authMethod, payload };
  }

  /**
  * Applies authentication headers to the request.
  */
  attachAuthToRequest() {
    const { authMethod, payload } = this.getAuthData();

    if (!payload) return;

    switch (authMethod) {
      case AuthMethods.BASIC:
        if (payload.username && payload.password) {
          const base64 = btoa(`${payload.username}:${payload.password}`);
          this.appendHeader('Authorization', `Basic ${base64}`);
        }
        break;
      case AuthMethods.JWT:
        if (payload.token) {
          this.appendHeader('X-JWT-Token', payload.token);
        }
        break;
      default:
        throw new Error(`Unknown authentication type: ${authMethod}`);
    }
  }

  async fetch() {
    if (URLRequest.xhr) {
      this.attachAuthToRequest();

      const url = this.url;
      const body = this.body;
      const method = this.method;
      const headers = this.headers;
      const credentials = this.credentials;

      try {
        console.log(this.asCurl);
        const result = await URLRequest.xhr(url, { method, headers, credentials, body });
        return checkStatus(result);
      } catch (e) {
        return checkError(e);
      }
    }

    return Promise.reject('Fetch method is not defined.');// eslint-disable-line new-cap
  }

  get asCurl() {
    try {
      this.attachAuthToRequest();

      const href = this.href;
      const body = this.body;
      const method = this.method;
      const headers = this.headers;
      const cmd = ['curl'];

      // method
      cmd.push('-X');
      cmd.push(method || 'GET');

      // headers
      Object.keys(headers || {}).forEach((key) => {
        const val = headers[key];
        cmd.push('-H');
        cmd.push(`${key}:${val}`);
      });

      if (body) {
        cmd.push('--data-binary');
        if (body instanceof FormData) {
          // eslint-disable-next-line no-restricted-syntax
          for (const pair of body.entries()) {
            cmd.push(`name=${pair[0]}; boundary=${pair[1]}`);
          }
        } else {
          cmd.push(`${body}`);
        }
      }

      // curl options
      // if (opts.verbose) cmd.push('-v');
      // if (opts.headers) cmd.push('-i');

      cmd.push(href);

      return `$ ${shellescape(cmd)}`;
    } catch (e) {
      console.error(e);
      return 'Curl failed';
    }
  }
}


/**
 * #######################################
 *                CONFIG
 * #######################################
 */
URLRequest.baseURL = apiURL;
URLRequest.basePath = apiBasePath;
URLRequest.xhr = window.fetch;
URLRequest.authMethod = 'basic';
URLRequest.authentications = new Map();

URLRequest.NEW = (path, method = 'POST') => {
  const request = new URLRequest();
  request.setMethod(method);

  if (isHTTPUrl(path)) {
    request.setURL(path);
  } else {
    request.setPath(path);
  }

  return request;
};

URLRequest.PUT = url => URLRequest.NEW(url, 'PUT');
URLRequest.GET = url => URLRequest.NEW(url, 'GET');
URLRequest.POST = url => URLRequest.NEW(url, 'POST');
URLRequest.PATCH = url => URLRequest.NEW(url, 'PATCH');
URLRequest.DELETE = url => URLRequest.NEW(url, 'DELETE');
