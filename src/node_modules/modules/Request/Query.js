import AbstractQuery from './AbstractQuery.js';
import URLRequest from './URLRequest';

const kCount = Symbol('count');
const kRequest = Symbol('request');

export default class Query extends AbstractQuery {
  constructor(request) {
    super();
    this[kRequest] = request;
  }

  async find() {
    const response = await this[kRequest].fetch();
    const contentType = response.headers.get('Content-Type') || '';
    if (contentType.indexOf('application/json') === -1) {
      return [];
    }

    const responseData = await response.json();

    // todo исправить костыль с передачей списков от сервера
    if (Array.isArray(responseData)) {
      this[kCount] = responseData.length;
      return responseData;
    }

    this[kCount] = responseData.totalElements;
    return responseData.content;
  }

  async count() {
    return this[kCount];
  }

  limit(size) {
    this[kRequest].appendUrlParams({ size });
  }

  skip(offset) {
    this[kRequest].appendUrlParams({ offset });
  }

  page(page) {
    this[kRequest].appendUrlParams({ page });
  }

  equalTo(key, val) {
    this[kRequest].appendPayload({ [key]: val });
  }

  startsWith(key, val) {
    this[kRequest].appendUrlParams({ [key]: val });
  }

  ascending(sort) {
    this[kRequest].appendUrlParams({ sort: `${sort},asc` });
  }

  descending(sort) {
    this[kRequest].appendUrlParams({ sort: `${sort},desc` });
  }
}


Query.GET = (...args) => new Query(URLRequest.GET(...args));
Query.PUT = (...args) => new Query(URLRequest.PUT(...args));
Query.POST = (...args) => new Query(URLRequest.POST(...args));
Query.PATCH = (...args) => new Query(URLRequest.PATCH(...args));
Query.DELETE = (...args) => new Query(URLRequest.DELETE(...args));
