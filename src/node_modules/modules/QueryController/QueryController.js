import { noop, defaults, isObject,
  isFunction, isEmpty, extend, defer,
  groupBy, last, sortBy, isNumber, constant, indexOf } from 'underscore';
import IndexPath from './IndexPath';

const defaultDelegate = {
  queryForRequest: noop,
  queryObjectsDidAppend: noop,
  queryObjectsWillAppend: noop,
  queryChangeStates: noop,
  queryDidChangeStates: noop,
  queryObjectsWillLoad: noop,
  queryObjectsDidLoad: noop,
  queryShouldClearObjects: constant(true),
};

const initialArray = (v) => {
  if (!Array.isArray(v)) return [v];
  return v;
};

const kStateKey = Symbol('state');
const kPropsKey = Symbol('props');
const kDelegateKey = Symbol('delegate');

export default class QueryController {
  constructor(delegate = defaultDelegate, props = {}) {
    this[kStateKey] = {
      objects: new Set(),
      countObjects: 0,
      currentPage: 0,
      firstLoad: true,
      lastLoadCount: -1,
      loading: false,
    };

    this[kPropsKey] = defaults(props || {}, {
      parseClassName: '',
      objectsPerPage: 25,
      countEnabled: true,
      paginationEnabled: true,
    });

    this[kDelegateKey] = delegate;
  }

  setState(prefs) {
    if (isObject(this[kDelegateKey]) && isFunction(this[kDelegateKey].queryChangeStates)) {
      this[kDelegateKey].queryChangeStates(this, prefs);
    }

    const oldStates = this[kStateKey];
    this[kStateKey] = extend(oldStates, prefs);

    if (isObject(this[kDelegateKey]) && isFunction(this[kDelegateKey].queryDidChangeStates)) {
      this[kDelegateKey].queryDidChangeStates(this);
    }
  }

  isEmpty() { return isEmpty([...this]); }

  map = iteratee => [...this].map(iteratee);

  groupBy = iteratee => groupBy([...this], iteratee);

  find = iteratee => [...this].find(iteratee);

  filter = predicate => [...this].filter(predicate);

  last = () => last([...this]);

  sortBy = sort => sortBy([...this], sort);

  count() {
    if (this[kPropsKey].countEnabled) {
      return this[kStateKey].countObjects;
    }
    return [...this].length;
  }

  countPage() {
    return Math.ceil(this.count() / this.objectsPerPage());
  }

  isPagination() {
    return this[kPropsKey].paginationEnabled;
  }

  objectsPerPage() {
    return this[kPropsKey].objectsPerPage;
  }

  currentPage() {
    return this[kStateKey].currentPage;
  }

  shouldLoadMore() {
    return this[kPropsKey].paginationEnabled
      && [...this].length !== 0
      && (this[kStateKey].lastLoadCount === -1
      || (this[kStateKey].lastLoadCount >= this[kPropsKey].objectsPerPage));
  }

  objectAtIndexPath(indexPath) {
    const objects = [...this];

    if (indexPath instanceof IndexPath) {
      return objects[indexPath.row];
    } else if (isNumber(indexPath)) {
      return objects[indexPath];
    }
    return false;
  }

  reject(model) {
    const objects = this[kStateKey].objects;
    objects.delete(model);
    this.setState({ objects });
  }

  concat(model) {
    if (this.indexOf(model) === -1) {
      const objects = this[kStateKey].objects;
      objects.add(model);
      this.setState({ objects });
    }
  }

  indexOf = item => indexOf([...this], item);

  isLoading = () => this[kStateKey].loading;

  /**
   * Получем запрос от делегата
   * @returns {Query}
   */
  async queryForRequest() {
    if (isObject(this[kDelegateKey]) && isFunction(this[kDelegateKey].queryForRequest)) {
      return this[kDelegateKey].queryForRequest(this);
    }

    throw new Error('The queryForRequest method is not implemented yet');
  }

  async objectsWillLoad() {
    this.setState({ loading: true });

    if (isObject(this[kDelegateKey]) && isFunction(this[kDelegateKey].queryObjectsWillLoad)) {
      await this[kDelegateKey].queryObjectsWillLoad(this);
    }
  }

  /**
   * Завершаем запрос результатом
   * @param page
   * @param results
   * @returns {Promise.<*>}
   */
  async objectsDidLoad(page, results) {
    this.setState({
      firstLoad: false,
      loading: false,
      currentPage: page,
    });

    if (isObject(this[kDelegateKey]) && isFunction(this[kDelegateKey].queryObjectsDidLoad)) {
      await this[kDelegateKey].queryObjectsDidLoad(this, results);
    }

    return results;
  }

  /**
   * Новые объекты будут добавлены в коллекцию. Возможность изменить полученный набор.
   */
  async objectsWillAppend(source, clear) {
    let results = initialArray(source);
    let needClear = clear;

    if (isObject(this[kDelegateKey]) && isFunction(this[kDelegateKey].queryObjectsWillAppend)) {
      results = await this[kDelegateKey].queryObjectsWillAppend(this, results);
    }

    if (isObject(this[kDelegateKey]) && isFunction(this[kDelegateKey].queryShouldClearObjects)) {
      needClear = await this[kDelegateKey].queryShouldClearObjects(this, results);
    }

    if (needClear) {
      this.clear();
    }

    const objects = new Set([...this].concat(results));
    this.setState({ objects });
    return results;
  }

  /**
   * Добавил новый набор объектов.
   * @param results
   * @returns {Promise.<void>}
   */
  async objectsDidAppend(results) {
    if (isObject(this[kDelegateKey]) && isFunction(this[kDelegateKey].queryObjectsDidAppend)) {
      await this[kDelegateKey].queryObjectsDidAppend(this, results);
    }

    this.setState({
      lastLoadCount: results.length,
    });

    return results;
  }

  /**
   * Видоизменяем запрос для пагинации
   * @param query
   * @param page
   */
  alterQuery(query, page) {
    if (this[kPropsKey].objectsPerPage > 0) {
      query.limit(this[kPropsKey].objectsPerPage);

      if (this[kPropsKey].paginationEnabled) {
        query.skip(page * this[kPropsKey].objectsPerPage);
      }

      query.page(page);
    }
  }

  shouldCountRequest(results) {
    return this[kStateKey].firstLoad && this[kPropsKey].countEnabled && results.length > 0;
  }

  loadObjectsWithPage = async (page, clear) => {
    try {
      const query = await this.queryForRequest();
      this.alterQuery(query, page);
      await this.objectsWillLoad();
      let results = await query.find();
      results = await this.objectsWillAppend(results, clear);
      await this.objectsDidAppend(results);
      await this.innerMeasurementCountObjects(query, results);
      await this.objectsDidLoad(page, results);

      return results;
    } catch (error) {
      await this.objectsDidLoad(this[kStateKey].currentPage, error);
      throw error;
    }
  };

  async innerMeasurementCountObjects(query, results) {//eslint-disable-line
    if (this.shouldCountRequest(results)) {
      const countObjects = await query.count();
      this.setState({ countObjects });
      return countObjects;
    }

    return 0;
  }

  slice(page) {
    const begin = page * this[kPropsKey].objectsPerPage;
    const end = (page + 1) * this[kPropsKey].objectsPerPage;

    return [...this].slice(begin, end);
  }

  clear = () => {
    this.setState({
      objects: new Set(),
      currentPage: 0,
      countObjects: 0,
      firstLoad: true,
    });
  };

  deferLoadObjects = () => defer(this.loadObjects);
  deferLoadWithPageObjects = (...args) => defer(this.loadObjectsWithPage, ...args);

  loadObjects = () => this.loadObjectsWithPage(0, true);

  loadNextPage = (clear = false) => {
    if (!this[kStateKey].loading) {
      return this.loadObjectsWithPage(this[kStateKey].currentPage + 1, clear);
    }

    return Promise.reject('The queryController is busy');
  };

  loadPrevPage = (clear = false) => {
    if (!this[kStateKey].loading) {
      return this.loadObjectsWithPage(Math.max(this[kStateKey].currentPage - 1, 0), clear);
    }
    return Promise.reject('The queryController is busy');
  };

  loadPage = (page, clear) => {
    if (!this[kStateKey].loading) {
      return this.loadObjectsWithPage(page, clear);
    }

    return Promise.reject('The queryController is busy');
  };

  fetchCurrentPage = () => this.loadPage(this.currentPage(), true);

  [Symbol.iterator]() {
    return this[kStateKey].objects.values();
  }
}
