import * as _ from 'underscore';
import moment from 'moment';
import objectPath from 'object-path';
import deepExtend from 'deep-extend';
import Promise from 'bluebird';
import validate from 'validate.js';
import Context from './Context.js';
import extractValue from './ExtractValueFromControl.js';
import ValidationError from './ValidationErrors.js';
import flatten from './Flatten.js';


validate.extend(validate.validators.datetime, {
  // The value is guaranteed not to be null or undefined but otherwise it
  // could be anything.
  parse(value) {
    return +moment.utc(value);
  },
  // Input is a unix timestamp
  format(value, options) {
    const format = options.dateOnly ? 'YYYY MM DD' : 'YYYY MM DD hh:mm:ss';
    return moment.utc(value).format(format);
  },
});

const defaultDelegate = {
  formWillChangeValues: _.noop,
  formDidChangeValues: _.noop,
};


function createContext(action, path, newValue, oldValue) {
  const context = new Context();
  context.setPath(path);
  context.setAction(action);
  context.setObject(newValue);
  context.setOldObject(oldValue);
  return context;
}

export default class MForm {
  constructor(delegate) {
    this.setData(this.getDefaultProps());
    this.delegate = delegate || defaultDelegate;

    this.setup();

    this.validate = this.validate.bind(this);
    this.extractor = MForm.defaultExtractor;
  }

  setData(data) {
    this.data = data;
  }

  setup() {
    this.lastError = null;
    this.processChange = false;
    this.processTransactions = false;
  }

  getDefaultProps() {
    return {};
  }

  setDelegate(delegate) {
    this.delegate = delegate || {};
  }

  beginUpdate() {
    this.processTransactions = true;
    if (_.isObject(this.delegate) && _.isFunction(this.delegate.formWillChangeValues)) {
      const context = createContext(Context.Actions.Transaction);
      try {
        this.delegate.formWillChangeValues(this, context);
      } catch (e) {
        console.error(e);
      }
    }
  }

  endUpdate() {
    if (_.isObject(this.delegate) && _.isFunction(this.delegate.formDidChangeValues)) {
      const context = createContext(Context.Actions.Transaction);
      try {
        this.delegate.formDidChangeValues(this, context);
      } catch (e) {
        console.error(e);
      }
    }
    this.processTransactions = false;
    this.processChange = false;
  }

  transaction(handler) {
    this.beginUpdate();
    handler(this);
    this.endUpdate();
  }

  retain() {
    if (this.processChange || this.processTransactions) {
      throw new Error('Processing');
    }

    this.processChange = true;
  }

  release() {
    if (!this.processTransactions) {
      this.processChange = false;
    }
  }

  willChangeValues = (context) => {
    this.retain();

    if (_.isObject(this.delegate) && _.isFunction(this.delegate.formWillChangeValues)) {
      try {
        this.delegate.formWillChangeValues(this, context);
      } catch (e) {
        console.error(e);
      }
    }

    this.release();
  };

  didChangeValues = (context) => {
    this.retain();

    if (_.isObject(this.delegate) && _.isFunction(this.delegate.formDidChangeValues)) {
      try {
        this.delegate.formDidChangeValues(this, context);
      } catch (e) {
        console.error(e);
      }
    }

    this.release();
  };

  toJSON() {
    return deepExtend({}, this.data);
  }

  equals(other) {
    if (other === this) return true;
    return other instanceof MForm
      && _.isEqual(this.data, other.data);
  }

  pick(...props) {
    const args = [this.toJSON()].concat(props);
    return _.pick(...args);
  }

  omit(...props) {
    const args = [this.toJSON()].concat(props);
    return _.omit(...args);
  }

  reset() {
    const context = createContext(Context.Actions.Extend);
    this.willChangeValues(context);
    this.setData(this.getDefaultProps());
    this.didChangeValues(context);
  }

  setValues(source, silent) {
    let object = source;

    if (_.isObject(object)) {
      object = flatten(object);

      if (!silent) {
        const context = createContext(Context.Actions.Extend);
        this.willChangeValues(context);
        this.setData(Object.assign({}, this.data, object));
        this.didChangeValues(context);
      } else {
        this.setData(Object.assign({}, this.data, object));
      }
    }

    return this;
  }

  unset(path) {
    const context = createContext(Context.Actions.Unset, path);
    this.willChangeValues(context);
    objectPath.del(this.data, path);
    this.didChangeValues(context);
  }

  exists(path) {
    return objectPath.has(this.data, path);
  }

  defaults() {
    const context = createContext(Context.Actions.Clear);
    this.willChangeValues(context);
    this.setData(this.getDefaultProps());
    this.didChangeValues(context);
  }

  clear() {
    const context = createContext(Context.Actions.Clear);
    this.willChangeValues(context);
    this.setData({});
    this.didChangeValues(context);
  }

  equal(path, compare) {
    return _.isEqual(this.getObject(path), compare);
  }

  notEqual(path, compare) {
    return !_.isEqual(this.getObject(path), compare);
  }

  isExists(path) {
    return objectPath.has(this.data, path);
  }

  isEmpty(path) {
    return _.isEmpty(this.getObject(path));
  }

  isNull(path) {
    return this.getObject(path) === null;
  }

  isNotEmpty(path) {
    return !_.isEmpty(this.getObject(path));
  }

  equalNumber(path, compare) {
    return _.isEqual(Number(this.getObject(path)), Number(compare));
  }

  date(key) {
    const date = this.getObject(key);
    if (date) {
      return new Date(date);
    }

    return null;
  }

  getObjectNotNull(key, defaultValue) {
    const value = this.getObject(key, defaultValue);

    if (value === null) {
      return defaultValue;
    }

    return value;
  }

  // alias
  get(key, defaultValue) {
    return this.getObject(key, defaultValue);
  }

  getObject(key, defaultValue) {
    return objectPath.get(this.data, key, defaultValue);
  }

  setObject(path, object) {
    const context = createContext(Context.Actions.Set, path, object, this.getObject(path));
    this.willChangeValues(context);
    objectPath.set(this.data, path, context.getObject());
    this.didChangeValues(context);
  }

// remove a instance of given path from an array field.
  delObject(path) {
    const context = createContext(Context.Actions.Delete, path);
    this.willChangeValues(context);
    objectPath.del(this.data, path);
    this.didChangeValues(context);
  }

// append the given objects to the end of an array field.
  addObject(path, target) {
    let object = target;

    if (_.isUndefined(object)) {
      object = this.getDefaultPropsForKey(path);
    }

    let value = this.getObject(path, []);
    value = value.slice();

    if (Array.isArray(value)) {
      value.push(object);
    } else {
      value = [object];
    }

    this.setObject(path, value);

    return object;
  }

  insertObjectAt(path, index, target) {
    let object = target;

    if (_.isUndefined(object)) {
      object = this.getDefaultPropsForKey(path);
    }

    let value = this.getObject(path, []);
    value = value.slice();

    if (Array.isArray(value)) {
      value.splice(index, 0, object);
    } else {
      value = [object];
    }

    this.setObject(path, value);

    return object;
  }

// The alias addUniqueObject
  addUnique(path, object) {
    this.addUniqueObject(path, object);
    return this;
  }

  // Add only the given objects which aren't already contained
  // in an array field to that field.
  // The position of the insert is not guaranteed.
  addUniqueObject(path, source) {
    let object = source;

    if (_.isUndefined(object)) {
      object = this.getDefaultPropsForKey(path);
    }

    let value = this.getObject(path, []);
    value = value.slice();

    if (Array.isArray(value)) {
      if (_.indexOf(value, object) === -1) {
        value.push(object);
      } else {
        return object;
      }
    } else {
      value = [object];
    }

    this.setObject(path, value);

    return object;
  }

  containedIn(path, object) {
    const value = this.getObject(path, []);
    return value.indexOf(object) !== -1;
  }

  intersectionIn(path, objects) {
    const value = this.getObject(path, []);
    return _.intersection(value, objects).length === objects.length;
  }

  mapObject(path, predict) {
    let items = this.getObject(path, []);
    if (Array.isArray(items)) {
      items = items.map(predict);
    }
    this.setObject(path, items);
  }

// The alias removeObject
  remove(path, object) {
    if (Array.isArray(object)) {
      this.removeObjectsInArray(path, object);
    } else {
      this.removeObject(path, object);
    }

    return this;
  }

// remove a instance from an array field.
  removeObject(path, object) {
    let value = this.getObject(path, []);
    value = value.slice();

    if (Array.isArray(value)) {
      const index = value.indexOf(object);
      if (index > -1) {
        value.splice(index, 1);
      }
    } else {
      value = [];
    }

    this.setObject(path, value);
  }

// remove all instances of each given object from an array field.
  removeObjectsInArray(key, objects) {
    for (let i = 0, l = objects.length; i < l; i += 1) {
      this.removeObject(key, objects[i]);
    }
  }

  getDefaultPropsForKey() {
    return {};
  }

  /** MARK: dom wrapper */

  wrapperObjectChange() {
    return (e) => {
      this.setValues(this.extractor(e));
    };
  }

  wrapperConstant(path, object) {
    return () => {
      this.setObject(path, object);
    };
  }

  wrapperChange(path) {
    return (e) => {
      this.setObject(path, this.extractor(e));
    };
  }

  wrapperChangeDate(path, format) {
    return (e, date) => {
      this.setObject(path, moment(date).format(format));
    };
  }

  wrapperDelObject(path) {
    return () => {
      this.delObject(path);
    };
  }

  wrapperAddObject(path) {
    return (e) => {
      this.addObject(path, this.extractor(e));
    };
  }

  /**
   * Checkbox
   * var form = {
   *   milk: {}
   * }
   * <Checkbox onChange={form.wrapperTriggerInObject('milk', {})}>
   * @param path
   * @param object
   * @returns {function(*=)}
   */
  wrapperTriggerInObject(path, object) {
    return (e) => {
      const value = this.extractor(e);

      if (value) {
        this.setObject(path, object);
      } else {
        this.unset(path);
      }
    };
  }

  /**
   * Checkbox
   * @param path
   * @param object
   * @returns {function(*=)}
   */
  wrapperTriggerInArray(path, object) {
    return (e) => {
      const value = this.extractor(e);

      if (value) {
        this.addUnique(path, object);
      } else {
        this.removeObject(path, object);
      }
    };
  }

  wrapperDefaults() {
    return () => {
      this.defaults();
    };
  }

  wrapperClear() {
    return () => {
      this.clear();
    };
  }

  whitelist() {
    return false;
  }

  getDefaultConstraints() {
    return {};
  }

  shouldRejectDefaultInArray() {
    return false;
  }

  cleanAttributes(attrs) {
    const whitelist = this.whitelist();
    return whitelist ? validate.cleanAttributes(attrs, whitelist) : attrs;
  }

  transform(attrs) {
    if (this.shouldRejectDefaultInArray()) {
      const iteratee = this.getDefaultPropsForKey.bind(this);
      return MForm.pickArray(attrs, iteratee);
    }

    return attrs;
  }

// Validate the form attributes
  validate(source) {
    let constraints = source;

    if (!_.isObject(constraints)) {
      constraints = this.getDefaultConstraints();
    }

    let attributes = this.cleanAttributes(this.toJSON());
    attributes = this.transform(attributes);

    if (_.keys(constraints).length === 0) {
      return new Promise((resolve) => {
        resolve(attributes);
      });
    }

    return MForm.validate(attributes, constraints);
  }
}

MForm.defaultExtractor = extractValue;
MForm.flatten = flatten;
MForm.assign = (delegate, object) => {
  const form = new MForm(delegate);
  form.setValues(object, true);
  return form;
};
MForm.empty = () => MForm.assign({});
MForm.pickArray = (attrs, iteratee = {}) => _.mapObject(attrs, (val, key) => {
  if (Array.isArray(val)) {
    return _.chain(val.slice()).reject(iteratee(key)).compact().value();
  }
  return val;
});
MForm.validateAttributes = { fullMessages: false, wrapErrors: ValidationError };
MForm.validate = (attr, c) => validate.async(attr, c, MForm.validateAttributes);
