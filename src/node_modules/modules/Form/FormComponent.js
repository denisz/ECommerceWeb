import {Component} from 'react';
import {isFunction, isObject, omit} from 'underscore';
import assert from 'assert';
import deepExtend from 'deep-extend';
import DialogController from './DialogController';
import MForm from './MForm';
import FormControlValue from './FormControlValue';
import {FormClearErrors, FormErrorHandler} from './ErrorHandler';
import {Lock} from 'modules/Lock';

export default class Form extends Component {
  static get separatorForPath() {
    return '.';
  }

  static createPathForRef(...tokens) {
    return tokens.join(Form.separatorForPath);
  }

  constructor(props = {}) {
    super(props);

    const form = this.getDefaultModel(props);
    const initialData = this.getDataForModel(props);
    const initialState = this.getInitialState(props, form);

    this.state = Object.assign({
      form,
      validate: true,
      error: false,
      dialogs: new DialogController(this),
      lock: new Lock(this),
    }, initialState);

    assert(isObject(this.state.form),
        'Object is not recognized as a form model.');

    form.setValues(initialData, true);
  }

  getInitialState(props) {
    return {};
  }

  componentWillMount() {
  }

  componentDidMount() {
    if (isFunction(this.props.onRef)) {
      this.props.onRef(this);
    }
  }

  componentWillReceiveProps(nextProps) {
    if (this.shouldUpdateDataWillReceiveProps()) {
      const {form} = this.state;
      const newData = this.getDataForModel(nextProps);
      form.setValues(newData, true);
    }
  }

  componentWillUnmount() {
    if (isFunction(this.props.onRef)) {
      this.props.onRef(undefined);
    }
  }

  async handleSubmit() {
    const { form } = this.state;
    return form.validate();
  }

  onSubmit = async () => {
    const { lock } = this.state;

    try {
      await lock.tryLock();
      await this.formWillSubmit();
      const attrs = await this.handleSubmit();
      this.setState({
        validate: true,
        error: false,
      });
      await this.formDidSubmit(attrs);
      lock.unlock();
      return attrs;
    } catch (error) {
      lock.unlock();
      await this.formFailedSubmit(error);
      throw error;
    }
  };

  getDefaultModel(props) {
    if (props.form instanceof MForm) {
      return props.form;
    }

    return new MForm(this);
  }

  getDataForModel(props) {
    let data = props.value || {};

    if (isFunction(data.toJSON)) {
      data = data.toJSON();
    }

    if (isObject(data)) {
      data = deepExtend({}, data);
    } else if (Array.isArray(data)) {
      data = [...data];
    }

    return omit(data, (value) => {
      if (value === null) return true;
      // if (Array.isArray(value)) return value.length === 0;
      return false;
    });
  }

  /**
   *
   * @returns {boolean}
   */
  shouldUpdateDataWillReceiveProps() {
    return false;
  }

  async formWillSubmit() {
    FormClearErrors(this.recursiveFindControl());
  }

  async formDidSubmit(attrs) {
    if (isFunction(this.props.onSubmit)) {
      await this.props.onSubmit(attrs);
    }
  }

  async formFailedSubmit(error) {
    this.formHandleError(error);
  }

  formHandleError(error) {
    FormErrorHandler(error, this.recursiveFindControl());
    this.setState({validate: false, error});
  }

  getControl(...path) {
    if (isObject(this.refs)) {
      return this.refs[Form.createPathForRef([].concat(...path))];
    }
    return null;
  }

  linkControl(...path) {
    return {
      onRef: (ref) => {
        this.refs[Form.createPathForRef([].concat(...path))] = ref;
      },
    };
  }

  formDidChangeValues(form) {
    this.setState({form});

    if (isFunction(this.props.onChange)) {
      this.props.onChange(Form.WrapValue(form.toJSON()));
    }

    if (this.props.debug) {
      console.log(form.toJSON());
    }
  }

  recursiveFindControl = () => {
    const controls = {};

    if (isObject(this.refs)) {
      Object.keys(this.refs).forEach((key) => {
        const control = this.refs[key];
        // todo: Replace into instanceOf FormComponent
        if (isFunction(control.recursiveFindControl)) {
          const controlRefs = control.recursiveFindControl();
          const usePrefix = !key.startsWith('_');

          Object.keys(controlRefs).forEach((token) => {
            if (!usePrefix) {
              controls[token] = controlRefs[token];
            } else {
              const path = Form.createPathForRef(key, token);
              controls[path] = controlRefs[token];
            }
          });
        } else {
          controls[key] = this.refs[key];
        }
      });
    }

    return controls;
  };

  performError({message}) {
    this.setState({error: message});
  }

  // MARK: Implements Dialog Delegate
  dialogsDidChange(dialogs) {
    this.setState({dialogs});
  }

  // MARK: Implements Lock Delegate
  lockDidChange(lock) {
    this.setState({ lock });
  }
}

Form.WrapValue = FormControlValue;
