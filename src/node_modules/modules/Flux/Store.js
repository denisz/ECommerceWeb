import { has, isEmpty } from 'underscore';
import EventEmitter from './EventEmitter';

const isFunction = object => typeof object === 'function' || false;
function capitalizeFirstLetter(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

export default class Store extends EventEmitter {
  constructor() {
    super();
    this.state = {};

    Object.defineProperty(this, 'listenables', {
      set(newValue) {
        this.listenTo(...[].concat(newValue));
      },
    });
  }

  listenTo(...arrayActions) {
    for (const actions of arrayActions) { //eslint-disable-line
      actions.addListener('invoke', this.dispatch.bind(this));
    }
  }

  async dispatch(actionName, ...args) {
    const method = `on${capitalizeFirstLetter(actionName)}`;
    if (isFunction(this[method])) {
      await this.willDispatch(actionName, ...args);
      const result = this[method](...args);
      await this.didDispatch(actionName, ...args);
      return result;
    }

    return false;
  }

  willDispatch() {}

  didDispatch() {}

  setState(...args) {
    const transforms = this.transforms;
    const newState = Object.assign({}, ...args);

    for (const [key, handler] of Object.entries(transforms)) { //eslint-disable-line
      newState[key] = handler(newState[key]);
    }

    this.state = newState;
    this.emit('update', this, this.state);
  }

  // todo:
  // updateState(...args) {
  //   this.setState(this.state, ...args);
  // }

  get(field, defaultValue) {
    return this.state[field] || defaultValue;
  }

  isEmpty() {
    return isEmpty(this.state);
  }

  exists(field) {
    return has(this.state, field);
  }

  get transforms() {
    return {};
  }

  listen(callback) {
    this.addListener('update', callback);
    return () => {
      this.removeAllListener('update', callback);
    };
  }

  toJSON() {
    return Object.freeze(this.state);
  }
}
